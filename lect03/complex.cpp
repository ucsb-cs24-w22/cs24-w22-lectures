//complex.cpp
//Lecture 3 01/10
/* Review basics of classes */

/* Lecture 1: Abstract Data Types */
/* Example: Datatype to represent complex numbers (could have been a struct)
In general a complex number is of the form: a + j*b, 
where  a: real part  b: imaginary part j = sqrt(-1) */
/* complex c1; c1 is an object */

/* Lectures 2 and 3: Big 4: Special function of any class, 
                     C++ provides some default implementations */
/*
    1. Constructor: Function used to initial objects
    2. Destructor: Function that "clean up" tasks right BEFORE an object 
                   is removed from memory
    3. Copy constructor 
    4. Copy assignment operator
*/


#include <iostream>
#include <cmath>
using namespace std;
class complex
{
private:
    // member variables are typically private which means 
    // they can only be accessed by member functions of the class
    double real;
    double imag;

public:
    // Member functions and variables in the public region can be accessed 
    // by code outside the class (non-member fuunctions) 
    
    // parametrized constructor with default values for the params
    complex(double re = 0, double im = 0 ):real(re), imag(im) {
       // cout<<"Called parametrized constructor"<<endl;
    } 
    // this code is generated by default
    //DONT'T FORGET TO SET THE PARAMETER FOR THE 
    //COPY CONSTRUCTOR TO BE A CONST REFERENCE
    complex(const complex& other){
        cout<<"\nCalling Copy constructor"<<endl;
        
        real = other.real;
        imag = other.imag;
    }

    ~complex(){
      //cout<<"Called destructor"<<endl;
    }

    // getters (accessors): return value of member variables
    double getImag() const{
        return imag;
    }
    // the const keyword at the end of the function means that
    // the function getImag() cannot modify any of the member variables.
    // Trying to modify the member variables, will result in a compiler error
    double getReal() const{
        //real = 3; this would result in a compiler error
        return real;
    
    }
    void print() const{
        if(imag>=0){
            cout<<real<<" + "<<imag<<"j";
        }else{
            cout<<real<<" - "<<-1*imag<<"j";
        }

    }

    double magnitude() const{
        return sqrt(real*real + imag*imag);
    }



};


void foo(complex c){ // pass by value, copy constructor is called
    cout<<"Called foo"<<endl;
}

void foo2(complex& c){ // pass by reference, no constructor is called
    cout<<"Called foo"<<endl;
}

complex operator+(complex& lhs, complex& rhs){
    //implicit object: this
    //second
    return  complex {lhs.getReal() + rhs.getReal(), lhs.getImag() + rhs.getImag()};
            
}


// overloaded the operator<< for complex class
// non-member function
void operator<<(ostream& cout, complex& c1){

    c1.print();

}

int main(int argc, char const *argv[])
{
    complex c1, c2; // c1 and c2 are objects of type complex
                    // (1): This statement is calling a function: constructor
                    // (2): If no constructor is defined, then compiler provides
                    //      a default one but the member variables will have junk values
    
    //complex()
    foo(c1);

    
    complex c3 {10, 20}; //c++11 notation similar to array declaration int arr[] {1, 2, 3};
                        // (1): Calls a constructor

    complex c4 {10}; // default value of 0 for imag is used
    // c1, c2, c3, c4 are on the stack because they are local to main

    complex* c5 = new complex {40, 50};
    // c5 is a pointer to type complex, c5 is on the stack but the complex object that 
    // its pointing to is on the heap

   

    cout<<"Printing out the value of the pointer c5: "<<c5<<endl;
    cout<<c1;// function call operator<<(cout, c1); cout.operator<<(c1)
    cout<<endl;
    cout<<c3;
    cout<<endl;
    cout<<c4;
    cout<<endl;
    cout<<*c5;
    cout<<endl;

    complex c6;
    c6 = c1 + c2; // compiler translates the statement to c6 = operator+(c1, c2);
    cout<<c6;

    complex c8 {10, 20};

    complex c7 {*c5}; // default copy constructor

    cout<<"\nc5: "<< *c5;
    cout<<"\nc7: "<< c7;
    cout<<endl;

 
    delete c5; //deletes the object that c5 points to on the heap
    
    return 0;
}
