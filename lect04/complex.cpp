//complex.cpp
//Lecture 4: 01/12
//Github repo for lectures: https://github.com/ucsb-cs24-w22/cs24-w22-lectures
//Organize code in C++

#include <iostream>
#include <cmath>
#include "complex.h" //preprocessing command to the compiler
using namespace std;

complex::complex(double re, double im ):real(re), imag(im) {
    // cout<<"Called parametrized constructor"<<endl;
}

//Prepend to the name of every member function
//complex::
// this code is generated by default
//DONT'T FORGET TO SET THE PARAMETER FOR THE 
//COPY CONSTRUCTOR TO BE A CONST REFERENCE
complex::complex(const complex & other){

    cout<<"Called copy constructor with parameter: ";
    other.print();        
    cout<<endl;
    real = other.real;
    imag = other.imag;
}


complex::~complex(){
    //cout<<"Called destructor"<<endl;
}

// getters (accessors): return value of member variables
double complex::getImag() const{
    return imag;
}
// the const keyword at the end of the function means that
// the function getImag() cannot modify any of the member variables.
// Trying to modify the member variables, will result in a compiler error
double complex::getReal() const{
    //real = 3; this would result in a compiler error
    return real;

}
void complex::print() const{
    if(imag>=0){
        cout<<real<<" + "<<imag<<"j";
    }else{
        cout<<real<<" - "<<-1*imag<<"j";
    }

}

double complex::magnitude() const{
    return sqrt(real*real + imag*imag);
}

complex complex::operator+(complex& rhs){
//implicit object: this
    cout<<"Called overloaded + with ...."<<endl;
    cout<<"lhs operand: ";
    this->print();
    cout<<"\trhs operand: ";
    rhs.print();      
    cout<<endl;  
    return  complex {real + rhs.getReal(), imag + rhs.getImag()};

}


// ALternate implementation for the + operator as a non-member function
// complex operator+(complex& lhs, complex& rhs){
//     return  complex {lhs.getReal() + rhs.getReal(), lhs.getImag() + rhs.getImag()};
            
// }


// overloaded the operator<< for complex class
// non-member function
ostream& operator<<(ostream& out, complex& c1){
    //cout<<"Calling overloaded <<"<<endl;
    c1.print();
    return out;
}

//cout<<c1;
//opertaor<<(cout, c1)

